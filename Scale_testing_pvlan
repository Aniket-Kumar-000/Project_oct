########################################################################################################################
#
#TOPOLOGY :
# 				  ____________ 
#  				 |            |
# 				 |            |
#                |            |
#   Ixia --------| N3K Box    |----------- Ixia
#   		     |            | 
#  				 |            |      
# 				 |____________|
#                              
#                                                                                                  
#topology requirement :-   1 N3k box 
#                          2 Ixia Connections
#    					   
########################################################################################################################
from ats import tcl
from ats import aetest
from ats.log.utils import banner
from unicon.eal.dialogs import Dialog
from unicon.eal.dialogs import Statement

import time
import logging
import os
import sys
import re
import pdb
import json
import pprint
import socket
import struct
import inspect
import yaml
import random
import CSCpvlan_lib as buglib
import CSCwe32490_nr3f_lib as l2ptLib
from yaml import loader
from pyats.aetest.steps import Steps

log = logging.getLogger(__name__)
log.setLevel(logging.DEBUG)

global uut1           

class ForkedPdb(pdb.Pdb):
    '''A Pdb subclass that may be used
    from a forked multiprocessing child1
    '''
    def interaction(self, *args, **kwargs):
        _stdin = sys.stdin
        try:
            sys.stdin = open('/dev/stdin')
            pdb.Pdb.interaction(self, *args, **kwargs)
        finally:
            sys.stdin = _stdin

################################################################################
####                       COMMON SETUP SECTION                             ####
################################################################################

class common_setup(aetest.CommonSetup):
    @aetest.subsection
    def connect_to_devices(self,testscript,testbed,R1):
    
        global ixia_uut1_1 , ixia_uut1_2
        global uut1_ixia_intf1 , uut1_ixia_intf2
        global ixia_chassis_ip, ixia_tcl_server, ixia_ixnetwork_tcl_server,ixia_username, ixia_reset_flag
        
        global uut1 , tgen
        
        uut1=testbed.devices[R1]
        testscript.parameters['uut1'] = uut1
        
        tgen = testbed.devices['ixia']
        testscript.parameters['tgen'] = tgen
        
        tgen_attributes = tgen.connections.hltapi
        ixia_chassis_ip = str(tgen_attributes.ip)
        ixia_tcl_server = tgen_attributes.tcl_server
        ixia_ixnetwork_tcl_server = tgen_attributes.ixnetwork_tcl_server
        ixia_username = tgen_attributes.username
        ixia_reset_flag = tgen_attributes.reset
        
        #### Ixia Interfaces ################
        ixia_uut1_1 = testbed.devices['ixia'].interfaces['ixia_uut1_1']
        ixia_uut1_2 = testbed.devices['ixia'].interfaces['ixia_uut1_2']
        
        testscript.parameters['ixia_uut1_1'] = ixia_uut1_1
        testscript.parameters['ixia_uut1_2'] = ixia_uut1_2
        
        testscript.parameters['ixia_uut1_1'].name = testscript.parameters['ixia_uut1_1'].intf
        testscript.parameters['ixia_uut1_2'].name = testscript.parameters['ixia_uut1_2'].intf
        
        ixia_uut1_1 = ixia_uut1_1.intf
        ixia_uut1_2 = ixia_uut1_2.intf
        
        #### uut1 Interfaces ################
        uut1_ixia_intf1 = testbed.devices[R1].interfaces['uut1_ixia_intf1']
        testscript.parameters['uut1_ixia_intf1'] = uut1_ixia_intf1     
        testscript.parameters['uut1_ixia_intf1'].name = testscript.parameters['uut1_ixia_intf1'].intf
        
        uut1_ixia_intf2 = testbed.devices[R1].interfaces['uut1_ixia_intf2']
        testscript.parameters['uut1_ixia_intf2'] = uut1_ixia_intf2     
        testscript.parameters['uut1_ixia_intf2'].name = testscript.parameters['uut1_ixia_intf2'].intf
        
        uut1_ixia_intf1=uut1_ixia_intf1.intf
        uut1_ixia_intf2=uut1_ixia_intf2.intf
        
        log.info("Connecting to Device...")
        log.info("%s"%uut1.name)
        try:
            uut1.connect()
            log.info("Connection to %s Successful..."%uut1.name)
        except Exception as e:
            log.info("Connection to %s Unsuccessful "\
                      "Exiting error:%s"%(uut1.name,e))
            self.failed(goto=['exit'])
            
    @aetest.subsection    
    def configue_interface(self, testscript, testbed):

        cmd = f"""interface {uut1_ixia_intf1}
               switchport
               switchport mode trunk
               no shut"""
        uut1.configure(cmd)
                
        cmd = f"""interface {uut1_ixia_intf2}
               switchport
               switchport mode trunk
               no shut"""
        uut1.configure(cmd)
        
        uut1.execute("""sh running-config int %s"""%uut1_ixia_intf2)
        
    @aetest.subsection
    def connect_to_ixia(self, testscript, testbed):
        """Connect Ixia and get port handles"""
        ixia_port_list = [ixia_uut1_1, ixia_uut1_2]
        global ixia_
        global ixia_port_1_handle,ixia_port_2_handle
        
        status,port_handle = l2ptLib.connect_ixia(ixia_chassis_ip, ixia_tcl_server, ixia_ixnetwork_tcl_server, \
                                                        ixia_port_list, ixia_reset_flag, ixia_username)
        if status != True:
            log.error("\nFail to Connect Ixia!!")
            self.failed(goto=['exit'])
        else:
            ixia_port_1_handle = port_handle.split(' ')[0]
            ixia_port_2_handle = port_handle.split(' ')[1]
            log.info("\nixia_port_1_handle = {}".format(ixia_port_1_handle))
            log.info("\nixia_port_2_handle = {}".format(ixia_port_2_handle))
            self.passed("Connected Ixia and got port handles!!")
           
        ##############################################################
        # config the parameters for IXIA stream                      #
        ##############################################################
    
    @aetest.subsection
    def configure_ixia_interfaces(self):
        """Configure IPs to ixia interfaces"""
        global protocol_intf_handle_1,protocol_intf_handle_2,protocol_intf_handle_3,protocol_intf_handle_4,protocol_intf_handle_5,protocol_intf_handle_6,protocol_intf_handle_7,protocol_intf_handle_8,protocol_intf_handle_9,protocol_intf_handle_10
        global protocol_intf_handle_11,protocol_intf_handle_12,protocol_intf_handle_13,protocol_intf_handle_14,protocol_intf_handle_15,protocol_intf_handle_16,protocol_intf_handle_17,protocol_intf_handle_18,protocol_intf_handle_19,protocol_intf_handle_20
       
        intf_handle_list = []
        ixia_port_list = [ixia_port_1_handle, ixia_port_2_handle]
        #ForkedPdb().set_trace()
        k=10
        m=10
        i=30
        for j in range(0,10):
            args= "00:00:00:{0}:B1:D1".format(i)
            #ForkedPdb().set_trace()
            status,interface_handle = l2ptLib.config_ixia_L2_interfaces(ixia_port_1_handle,args,k)
            i=i+1
            k=k+12
        
            if status != True:
                log.error("\n Fail to configure mac address to port 1")
                self.failed(goto=['exit'])
            else:
                intf_handle_list.append(interface_handle)
                log.info("\nSuccessfully configured mac address to port 1")
        
        for h in range(0,10):
            args= "00:00:00:{0}:E1:B1".format(i)
            status,interface_handle = l2ptLib.config_ixia_L2_interfaces(ixia_port_2_handle,args,m)
            i=i+1
            m=m+12
            
            if status != True:
                log.error("\n Fail to configure mac address to port 2")
                self.failed(goto=['exit'])
            else:
                intf_handle_list.append(interface_handle)
                log.info("\nSuccessfully configured mac address to port 2")
                  

        protocol_intf_handle_1= intf_handle_list[0]
        protocol_intf_handle_2 = intf_handle_list[1]
        protocol_intf_handle_3 = intf_handle_list[2]
        protocol_intf_handle_4 = intf_handle_list[3]
        protocol_intf_handle_5 = intf_handle_list[4]
        protocol_intf_handle_6 = intf_handle_list[5]
        protocol_intf_handle_7 = intf_handle_list[6]
        protocol_intf_handle_8 = intf_handle_list[7]
        protocol_intf_handle_9 = intf_handle_list[8]
        protocol_intf_handle_10= intf_handle_list[9]
        protocol_intf_handle_11 = intf_handle_list[10]
        protocol_intf_handle_12 = intf_handle_list[11]
        protocol_intf_handle_13 = intf_handle_list[12]
        protocol_intf_handle_14 = intf_handle_list[13]
        protocol_intf_handle_15 = intf_handle_list[14]
        protocol_intf_handle_16 = intf_handle_list[15]
        protocol_intf_handle_17 = intf_handle_list[16]
        protocol_intf_handle_18 = intf_handle_list[17]
        protocol_intf_handle_19 = intf_handle_list[18]
        protocol_intf_handle_20 = intf_handle_list[19]
        
        log.info("\n\nConfigured interface handles:\n")
        log.info("protocol_intf_handle_1 : {}".format(protocol_intf_handle_1))
        log.info("protocol_intf_handle_2 : {}".format(protocol_intf_handle_2))
        log.info("protocol_intf_handle_3 : {}".format(protocol_intf_handle_3))
        log.info("protocol_intf_handle_4 : {}".format(protocol_intf_handle_4))
        log.info("protocol_intf_handle_5 : {}".format(protocol_intf_handle_5))
        log.info("protocol_intf_handle_6 : {}".format(protocol_intf_handle_6))
        log.info("protocol_intf_handle_7 : {}".format(protocol_intf_handle_7))
        log.info("protocol_intf_handle_8 : {}".format(protocol_intf_handle_8))
        log.info("protocol_intf_handle_9 : {}".format(protocol_intf_handle_9))
        log.info("protocol_intf_handle_10: {}".format(protocol_intf_handle_10))
        log.info("protocol_intf_handle_11: {}".format(protocol_intf_handle_11))
        log.info("protocol_intf_handle_12: {}".format(protocol_intf_handle_12))
        log.info("protocol_intf_handle_13: {}".format(protocol_intf_handle_13))
        log.info("protocol_intf_handle_14: {}".format(protocol_intf_handle_14))
        log.info("protocol_intf_handle_15: {}".format(protocol_intf_handle_15))
        log.info("protocol_intf_handle_16: {}".format(protocol_intf_handle_16))
        log.info("protocol_intf_handle_17: {}".format(protocol_intf_handle_17))
        log.info("protocol_intf_handle_18: {}".format(protocol_intf_handle_18))
        log.info("protocol_intf_handle_19: {}".format(protocol_intf_handle_19))
        log.info("protocol_intf_handle_20: {}".format(protocol_intf_handle_20))
        
        
        self.passed("IP configuration  to ixia interfaces Successful!!")    
    
    
    @aetest.subsection
    def configure_ixia_traffic_streams(self):
        """Configure regular traffic streams on ixia ports"""

        global traffic_stream_id_1,traffic_stream_id_2,traffic_stream_id_3,traffic_stream_id_4,traffic_stream_id_5,traffic_stream_id_6,traffic_stream_id_7,traffic_stream_id_8,traffic_stream_id_9,traffic_stream_id_10
        stream_handle_list = []
        #ForkedPdb().set_trace()
        intf_handle_list = [protocol_intf_handle_1, protocol_intf_handle_2, protocol_intf_handle_3, protocol_intf_handle_4, protocol_intf_handle_5, protocol_intf_handle_6, protocol_intf_handle_7, protocol_intf_handle_8, protocol_intf_handle_9, protocol_intf_handle_10, protocol_intf_handle_11, protocol_intf_handle_12, protocol_intf_handle_13, protocol_intf_handle_14, protocol_intf_handle_15, protocol_intf_handle_16, protocol_intf_handle_17, protocol_intf_handle_18, protocol_intf_handle_19, protocol_intf_handle_20]
        

        #####traffic stream Isolated to trunk secondary via trunk promiscous port ##########
        status,stream_handle = l2ptLib.config_traffic_stream1(protocol_intf_handle_1,protocol_intf_handle_11,'Traffic-Stream 1','1000','ethernet_vlan')
        
        if status != True:
            log.error("\n Fail to create first traffic stream")
            self.failed(goto=['exit'])
        else:
            stream_handle_list.append(stream_handle)
            log.info("\nSuccessfully created 1st traffic stream")
            
        status,stream_handle = l2ptLib.config_traffic_stream1(protocol_intf_handle_2,protocol_intf_handle_12,'Traffic-Stream 2','1000','ethernet_vlan')
        
        if status != True:
            log.error("\n Fail to create first traffic stream")
            self.failed(goto=['exit'])
        else:
            stream_handle_list.append(stream_handle)
            log.info("\nSuccessfully created 1st traffic stream")
            
        status,stream_handle = l2ptLib.config_traffic_stream1(protocol_intf_handle_3,protocol_intf_handle_13,'Traffic-Stream 3','1000','ethernet_vlan')
        
        if status != True:
            log.error("\n Fail to create first traffic stream")
            self.failed(goto=['exit'])
        else:
            stream_handle_list.append(stream_handle)
            log.info("\nSuccessfully created 1st traffic stream")
            
        status,stream_handle = l2ptLib.config_traffic_stream1(protocol_intf_handle_4,protocol_intf_handle_14,'Traffic-Stream 4','1000','ethernet_vlan')
        
        if status != True:
            log.error("\n Fail to create first traffic stream")
            self.failed(goto=['exit'])
        else:
            stream_handle_list.append(stream_handle)
            log.info("\nSuccessfully created 1st traffic stream")
            
        status,stream_handle = l2ptLib.config_traffic_stream1(protocol_intf_handle_5,protocol_intf_handle_15,'Traffic-Stream 5','1000','ethernet_vlan')
        
        if status != True:
            log.error("\n Fail to create first traffic stream")
            self.failed(goto=['exit'])
        else:
            stream_handle_list.append(stream_handle)
            log.info("\nSuccessfully created 1st traffic stream")
            
        status,stream_handle = l2ptLib.config_traffic_stream1(protocol_intf_handle_6,protocol_intf_handle_16,'Traffic-Stream 6','1000','ethernet_vlan')
        
        if status != True:
            log.error("\n Fail to create first traffic stream")
            self.failed(goto=['exit'])
        else:
            stream_handle_list.append(stream_handle)
            log.info("\nSuccessfully created 1st traffic stream")
            
        status,stream_handle = l2ptLib.config_traffic_stream1(protocol_intf_handle_7,protocol_intf_handle_17,'Traffic-Stream 7','1000','ethernet_vlan')
        
        if status != True:
            log.error("\n Fail to create first traffic stream")
            self.failed(goto=['exit'])
        else:
            stream_handle_list.append(stream_handle)
            log.info("\nSuccessfully created 1st traffic stream")
            
        status,stream_handle = l2ptLib.config_traffic_stream1(protocol_intf_handle_8,protocol_intf_handle_18,'Traffic-Stream 8','1000','ethernet_vlan')
        
        if status != True:
            log.error("\n Fail to create first traffic stream")
            self.failed(goto=['exit'])
        else:
            stream_handle_list.append(stream_handle)
            log.info("\nSuccessfully created 1st traffic stream")    
            
        status,stream_handle = l2ptLib.config_traffic_stream1(protocol_intf_handle_9,protocol_intf_handle_19,'Traffic-Stream 9','1000','ethernet_vlan')
        
        if status != True:
            log.error("\n Fail to create first traffic stream")
            self.failed(goto=['exit'])
        else:
            stream_handle_list.append(stream_handle)
            log.info("\nSuccessfully created 1st traffic stream")
            
        status,stream_handle = l2ptLib.config_traffic_stream1(protocol_intf_handle_10,protocol_intf_handle_20,'Traffic-Stream 10','1000','ethernet_vlan')
        
        if status != True:
            log.error("\n Fail to create first traffic stream")
            self.failed(goto=['exit'])
        else:
            stream_handle_list.append(stream_handle)
            log.info("\nSuccessfully created 1st traffic stream")    
############################################################################################################################           Done till here

        traffic_stream_id_1 = stream_handle_list[0]
        traffic_stream_id_2 = stream_handle_list[1]
        traffic_stream_id_3 = stream_handle_list[2]
        traffic_stream_id_4 = stream_handle_list[3]
        traffic_stream_id_5 = stream_handle_list[4]
        traffic_stream_id_6 = stream_handle_list[5]
        traffic_stream_id_7 = stream_handle_list[6]
        traffic_stream_id_8 = stream_handle_list[7]
        traffic_stream_id_9 = stream_handle_list[8]
        traffic_stream_id_10 = stream_handle_list[9]
        
        log.info("traffic_stream_id_1: {}".format(traffic_stream_id_1))
        log.info("traffic_stream_id_2: {}".format(traffic_stream_id_2))
        log.info("traffic_stream_id_3: {}".format(traffic_stream_id_3))
        log.info("traffic_stream_id_4: {}".format(traffic_stream_id_4))
        log.info("traffic_stream_id_5: {}".format(traffic_stream_id_5))
        log.info("traffic_stream_id_6: {}".format(traffic_stream_id_6))
        log.info("traffic_stream_id_7: {}".format(traffic_stream_id_7))
        log.info("traffic_stream_id_8: {}".format(traffic_stream_id_8))
        log.info("traffic_stream_id_9: {}".format(traffic_stream_id_9))
        log.info("traffic_stream_id_10: {}".format(traffic_stream_id_10))
        
        self.passed("Regular Ixia streams are configured Successfully!!")
        
    @aetest.subsection
    def start_traffic(self,testbed,testscript):
        global data_stream_ids
       
        
        data_stream_ids = [traffic_stream_id_1, traffic_stream_id_2, traffic_stream_id_3, traffic_stream_id_4, traffic_stream_id_5, traffic_stream_id_6, traffic_stream_id_7, traffic_stream_id_8, traffic_stream_id_9, traffic_stream_id_10]
        # ForkedPdb().set_trace()
        l2ptLib.run_traffic_stream1(traffic_stream_id_1)
        # ForkedPdb().set_trace()
        l2ptLib.run_traffic_stream1(traffic_stream_id_2)
        # ForkedPdb().set_trace()
        l2ptLib.run_traffic_stream1(traffic_stream_id_3)
        # ForkedPdb().set_trace()
        l2ptLib.run_traffic_stream1(traffic_stream_id_4)
        # ForkedPdb().set_trace()
        l2ptLib.run_traffic_stream1(traffic_stream_id_5)
        # ForkedPdb().set_trace()
        l2ptLib.run_traffic_stream1(traffic_stream_id_6)
        # ForkedPdb().set_trace()
        l2ptLib.run_traffic_stream1(traffic_stream_id_7)
        # ForkedPdb().set_trace()
        l2ptLib.run_traffic_stream1(traffic_stream_id_8)
        # ForkedPdb().set_trace()
        l2ptLib.run_traffic_stream1(traffic_stream_id_9)
        # ForkedPdb().set_trace()
        l2ptLib.run_traffic_stream1(traffic_stream_id_10)
        time.sleep(30)
        log.info("traffic started successfully")
        
        uut1.execute("show mac address-table dynamic")
        
        uut1.execute("show interface counters brief 1")
        
    @aetest.subsection
    def setup(self,testscript,testbed):
        global oUt
        global interfaces
        interfaces = []
        global file
        ran = (random.randint(0,100))
        file = (f"scale_{ran}.cfg")
        testscript.parameters['file'] = file
        uut1.configure(f"copy running-config {file}",timeout = 600)
        uut1.configure("default interface ethernet regex [1]/",timeout = 600)
        oUt = uut1.execute("sh int br")
        interfaces = re.findall(r'[Ee]th\d+(?:/\d+)+', oUt)
        testscript.parameters['interfaces'] = interfaces
        uut1.configure("feature private-vlan")
        
#################################################################################
class mem_leak_check_before_and_after_reload_pre_tests(aetest.Testcase):
    @aetest.test
    def mem_leak_check(self,testscript,testbed):
        log.info(banner("MEM-STATS"))
        out1 = []
        process = ["l2fm" , "ethpm" , "private-vlan"]
        for p in process:
            a = buglib.mem_leak(uut1,p)
            out1.append(a) 
        
        buglib.reload(uut1)  
        
        out2 = []
        for p in process:
            a = buglib.mem_leak(uut1,p)
            out2.append(a)
        
        if out1 == out2:
            log.info("Passed:mem-stats are in before reload and after reload")
            tab3 = '\t\t\t\t'
            tab2 = '\t\t\t'
            tab1 = '\t\t'
            log.info(f"Before reload{tab3}After reload")         
            log.info(f"l2fm:- {out1[0]}{tab2}l2fm:- {out2[0]}")
            log.info(f"ethpm:- {out1[1]}{tab2}ethpm:- {out2[1]}")
            log.info(f"private-vlan:- {out1[2]}{tab1}private-vlan:- {out2[2]}")
        elif out1 != out2:
            o = 0
            pount = 0
            v = 0
            log.info("mem-stats are not same in before reload and after reload")
            while o < len(process):
                if out1[o] == out2[o]:
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                elif out1[o] < out2[o]:    
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                    pount += 1
                    v = o
                elif out1[o] > out2[o]:
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                o += 1
            if pount != 0:
                self.failed(f" In {process[v]}:- before reload {out1[v]}\n after reload {out2[v]}")
                
        uut1.execute("show mac address-table dynamic")
        
        uut1.execute("show interface counters brief 1")        
                
        uut1.execute("python cliRunTime.py input_cli_file.txt",timeout = 3000)        
#################################################################################
class Test_1_(aetest.Testcase):                    
    @aetest.test
    def creating_Primary_Isolated_Community_Vlan(self,testbed,testscript):
        log.info(banner("CREATING  primary ,isolated ,community VLANs"))
        l = 1210
        end = int(l)
        uut1.configure(f"""vlan 10-{end}\n no shut""")
        
        log.info("***Ascending order pairs***")
        m = 607
        End = int(m)
        count = 10
        while(count <= End):
            vla = count 
            iso = count+1 
            com = count+2
            buglib.private_vlan(vla,iso,com,uut1)
            count+=3     
        
        log.info("***Descending order pairs***")
        n = 1207
        END = int(n)
        count = 610
        while(count <= END):
            com1 = count 
            iso1 = count+1 
            vla1 = count+2
            buglib.private_vlan(vla1,iso1,com1,uut1)
            count+=3  
            
        output = uut1.execute("show vlan private-vlan")
        log.info("***Ascending order check***")
        count = 10
        while(count <= End):
            p = str(count)
            i = str(count + 1)
            c = str(count + 2)
            pattern1 = fr"{p}\s*{i}\s*[Ii]solated"
            if re.findall(pattern1, output):
                pattern2 = fr"{p}\s*{c}\s*[Cc]ommunity"
                if re.findall(pattern2, output):
                    match = True
                else:
                    log.error("Something went wrong")
                    self.failed()
            elif "non-operational" in output:
                log.error("Some pvlan pairs showing non-operational")
                self.failed(goto=['exit'])
            else:
                log.error("Something went wrong")
                self.failed()
            count+=3
        if match:
            log.info("PASSED:Ascending pairs are present before reload")
        else:
            log.error("FAILED::Ascending pairs are not present before reload")
        
        for i in range(1, 11):
            print("-", end='', flush=True)
            time.sleep(1)
            
        log.info("\n***Descending order check***")
        count = 610
        while(count <= END):
            C = str(count)
            I = str(count + 1)
            P = str(count + 2)
            pattern1 = fr"{P}\s*{I}\s*[Ii]solated"
            if re.findall(pattern1, output):
                pattern2 = fr"{P}\s*{C}\s*[Cc]ommunity"
                if re.findall(pattern2, output):
                    match = True
                else:
                    log.error("Something went wrong")
                    self.failed()
            elif "non-operational" in output:
                log.error("Some pvlan pairs showing non-operational")
                self.failed()
            else:
                log.error("Something went wrong")
                self.failed()
            count+=3
        if match:
            log.info("PASSED:Ascending pairs are present before reload")
        else:
            log.error("FAILED::Ascending pairs are not present before reload")    
        
        log.info(banner("MEM-STATS"))
        out1 = []
        process = ["l2fm" , "ethpm" , "private-vlan"]
        for p in process:
            a = buglib.mem_leak(uut1,p)
            out1.append(a)
        
        buglib.reload(uut1)  
        
        out2 = []
        for p in process:
            a = buglib.mem_leak(uut1,p)
            out2.append(a)
        
        if out1 == out2:
            log.info("Passed:mem-stats are in before reload and after reload")
            tab3 = '\t\t\t\t'
            tab2 = '\t\t\t'
            tab1 = '\t\t'
            log.info(f"Before reload{tab3}After reload")         
            log.info(f"l2fm:- {out1[0]}{tab2}l2fm:- {out2[0]}")
            log.info(f"ethpm:- {out1[1]}{tab2}ethpm:- {out2[1]}")
            log.info(f"private-vlan:- {out1[2]}{tab1}private-vlan:- {out2[2]}")
        elif out1 != out2:
            o = 0
            pount = 0
            v = 0
            log.info("mem-stats are not same in before reload and after reload")
            while o < len(process):
                if out1[o] == out2[o]:
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                elif out1[o] < out2[o]:    
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                    pount += 1
                    v = o
                elif out1[o] > out2[o]:
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                o += 1
            if pount != 0:
                self.failed(f" In {process[v]}:- before reload {out1[v]}\n after reload {out2[v]}")
        
        output = uut1.execute("show vlan private-vlan")
        log.info("***Ascending order check***")
        count = 10
        while(count <= End):
            p = str(count)
            i = str(count + 1)
            c = str(count + 2)
            pattern1 = fr"{p}\s*{i}\s*[Ii]solated"
            if re.findall(pattern1, output):
                pattern2 = fr"{p}\s*{c}\s*[Cc]ommunity"
                if re.findall(pattern2, output):
                    match = True
                else:
                    log.error("Something went wrong")
                    self.failed(goto=['exit'])
            elif "non-operational" in output:
                log.error("Some pvlan pairs showing non-operational")
                self.failed(goto=['exit'])
            else:
                log.error("Something went wrong")
                self.failed(goto=['exit'])
            count+=3
        if match:
            log.info("PASSED:Ascending pairs are present after reload")
        else:
            log.error("FAILED::Ascending pairs are not present after reload")
            
        for i in range(1, 11):
            print("-", end='', flush=True)
            time.sleep(1)    
            
        log.info("\n***Descending order check***")
        count = 610
        while(count <= END):
            C = str(count)
            I = str(count + 1)
            P = str(count + 2)
            pattern1 = fr"{P}\s*{I}\s*[Ii]solated"
            if re.findall(pattern1, output):
                pattern2 = fr"{P}\s*{C}\s*[Cc]ommunity"
                if re.findall(pattern2, output):
                    match = True
                else:
                    log.error("Something went wrong")
                    self.failed(goto=['exit'])
            elif "non-operational" in output:
                log.error("Some pvlan pairs showing non-operational")
                self.failed(goto=['exit'])
            else:
                log.error("Something went wrong")
                self.failed(goto=['exit'])
            count+=3
        if match:
            log.info("PASSED:Ascending pairs are present after reload")
        else:
            log.error("FAILED::Ascending pairs are not present after reload")
            
        uut1.execute("show mac address-table dynamic")
        
        uut1.execute("show interface counters brief 1")    
        
        uut1.execute("python cliRunTime.py input_cli_file.txt",timeout = 3000)
################################################################################
###                          TESTCASE BLOCK                                  ###
################################################################################

#     ### If Interfaces taking in script file ###
#     ########################################### 

class Test_2_(aetest.Testcase):
    @aetest.test
    def creating_Promiscous_trunk_port_for_all_pairs(self,testbed,testscript):
    
        log.info(banner("CREATING PROMISCOUS on 1 INTERFACE"))
        global eth
        eth = interfaces[0]
        cmd = f""" int {eth}\n switchport\n switchport mode private-vlan trunk promiscuous\n switchport private-vlan trunk allowed vlan 1\n no shut"""
        uut1.configure(cmd)
        count = 10
        l = 607
        end = int(l)
        while(count <= end):
            vla = count 
            iso = count+1 
            com1 = count+2
            buglib.map(eth,vla,iso,com1,uut1)
            count+=3
        
        OuT = uut1.execute(f"show running-config int {eth}")
        print(f"Checks of running-config in int {eth}")
        count = 10
        l = 607
        end = int(l)
        while(count <= end):
            vla = count 
            iso = count+1 
            com1 = count+2
            pattern = fr'.*?{vla}\s*{iso}.*?{com1}'
            if re.findall(pattern, OuT):
                T = True
            else:
                log.error("FAILED")
                T = False
            count+=3
            
        if T:
            log.info("PASSED:promiscous port is present before reload")
        else:
            log.error("FAILED:promiscous port is not present before reload")
            self.failed()
        
        log.info(banner("MEM-STATS"))
        out1 = []
        process = ["l2fm" , "ethpm" , "private-vlan"]
        for p in process:
            a = buglib.mem_leak(uut1,p)
            out1.append(a) 
        
        buglib.ascii_reload(uut1)  
        
        out2 = []
        for p in process:
            a = buglib.mem_leak(uut1,p)
            out2.append(a)
        
        if out1 == out2:
            log.info("Passed:mem-stats are in before reload and after reload")
            tab3 = '\t\t\t\t'
            tab2 = '\t\t\t'
            tab1 = '\t\t'
            log.info(f"Before reload{tab3}After reload")         
            log.info(f"l2fm:- {out1[0]}{tab2}l2fm:- {out2[0]}")
            log.info(f"ethpm:- {out1[1]}{tab2}ethpm:- {out2[1]}")
            log.info(f"private-vlan:- {out1[2]}{tab1}private-vlan:- {out2[2]}")
        elif out1 != out2:
            o = 0
            pount = 0
            v = 0
            log.info("mem-stats are not same in before reload and after reload")
            while o < len(process):
                if out1[o] == out2[o]:
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                elif out1[o] < out2[o]:    
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                    pount += 1
                    v = o
                elif out1[o] > out2[o]:
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                o += 1
            if pount != 0:
                self.failed(f" In {process[v]}:- before reload {out1[v]}\n after reload {out2[v]}")
        
        OuT = uut1.execute(f"show running-config int {eth}")
        print(f"Checks of running-config in int {eth}")
        count = 10
        l = 607
        end = int(l)
        while(count <= end):
            vla = count 
            iso = count+1 
            com1 = count+2
            pattern = fr'.*?{vla}\s*{iso}.*?{com1}'
            if re.findall(pattern, OuT):
                T = True
            else:
                log.error("FAILED")
                T = False
            count+=3
            
        if T:
            log.info("PASSED:promiscous port is present after reload")
        else:
            log.error("FAILED:promiscous port is not present after reload")
            self.failed()
            
        uut1.execute("show mac address-table dynamic")
        
        uut1.execute("show interface counters brief 1")    
            
        uut1.execute("python cliRunTime.py input_cli_file.txt",timeout = 3000)    
            
    @aetest.cleanup
    def clean_n_default(self,testbed,testscript):      
        uut1.configure(f""" int {eth}\n default int {eth}""")
#################################################################################
class Test_3_(aetest.Testcase):
    @aetest.setup
    def creating_community_vlan_as_host_in_40_interface(self,testbed,testscript):
        log.info(banner(f"Making Community Vlan as host on 40 interface of {uut1.name}"))
        count = 10
        v = 0
        iso = 0
        c1 = 0
        for intf in interfaces:
            if intf != interfaces[40]:
                v = count
                iso = count+1
                c1 = count+2
                buglib.COM_host(intf,v,c1,uut1)
                count+=3
            else:
                break
        
        out=uut1.execute("""show vlan private-vlan""")
        a = 0
        count = 10
        while interfaces[a] != interfaces[40]:
            v = count
            iso = count+1
            c1 = count+2
            pattern = fr'^\s*{v}\s*{c1}\s*[Cc]ommunity\s*{interfaces[a]}\s*$'
            if re.findall(pattern, out, re.MULTILINE):
                T = True
            else:
              
                T = False
            count+=3
            a+=1
     
        if T:
            log.info("PASSED:community host is present before reload")
        else:
            log.error("FAILED:community host is not present before reload")
            self.failed()
        
        log.info(banner("MEM-STATS"))
        out1 = []
        process = ["l2fm" , "ethpm" , "private-vlan"]
        for p in process:
            a = buglib.mem_leak(uut1,p)
            out1.append(a) 
        
        buglib.reload(uut1)  
        
        out2 = []
        for p in process:
            a = buglib.mem_leak(uut1,p)
            out2.append(a)
        
        if out1 == out2:
            log.info("Passed:mem-stats are in before reload and after reload")
            tab3 = '\t\t\t\t'
            tab2 = '\t\t\t'
            tab1 = '\t\t'
            log.info(f"Before reload{tab3}After reload")         
            log.info(f"l2fm:- {out1[0]}{tab2}l2fm:- {out2[0]}")
            log.info(f"ethpm:- {out1[1]}{tab2}ethpm:- {out2[1]}")
            log.info(f"private-vlan:- {out1[2]}{tab1}private-vlan:- {out2[2]}")
        elif out1 != out2:
            o = 0
            pount = 0
            v = 0
            log.info("mem-stats are not same in before reload and after reload")
            while o < len(process):
                if out1[o] == out2[o]:
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                elif out1[o] < out2[o]:    
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                    pount += 1
                    v = o
                elif out1[o] > out2[o]:
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                o += 1
            if pount != 0:
                self.failed(f" In {process[v]}:- before reload {out1[v]}\n after reload {out2[v]}")
     
        out=uut1.execute("""show vlan private-vlan""")
        a = 0
        count = 10
        while interfaces[a] != interfaces[40]:
            v = count
            iso = count+1
            c1 = count+2
            pattern = fr'^\s*{v}\s*{c1}\s*[Cc]ommunity\s*{interfaces[a]}\s*$'
            if re.findall(pattern, out, re.MULTILINE):
                T = True
            else:
              
                T = False
            count+=3
            a+=1
     
        if T:
            log.info("PASSED:community host is present after reload")
        else:
            log.error("FAILED:community host is not present after reload")
            self.failed()
            
        uut1.execute("show mac address-table dynamic")
        
        uut1.execute("show interface counters brief 1")    
            
        uut1.execute("python cliRunTime.py input_cli_file.txt",timeout = 3000)    
            
    @aetest.cleanup
    def clean_n_default(self,testbed,testscript):     
        uut1.configure("default interface ethernet regex [1]/",timeout = 600)
#################################################################################        
class Test_4_(aetest.Testcase):
    @aetest.setup
    def creating_isolated_vlan_as_host_in_40_interface(self,testbed,testscript):
        log.info(banner(f"Making Isolated Vlan as host on 40 interface of {uut1.name}"))
        count = 10
        v = 0
        iso = 0
        c1 = 0
        for intf in interfaces:
            if intf != interfaces[40]:
                v = count
                iso = count+1
                c1 = count+2
                buglib.ISO_host(intf,v,iso,uut1)
                count+=3
            else:
                break
            
        oUt=uut1.execute("""show vlan private-vlan""")
        a = 0
        count = 10
        while interfaces[a] != interfaces[40]:
            v = count
            iso = count+1
            c1 = count+2
            pattern = fr'^\s*{v}\s*{iso}\s*[Ii]solated\s*{interfaces[a]}\s*$'
            if re.findall(pattern, oUt, re.MULTILINE):
                T = True
            else:
               
                T = False
            count+=3
            a+=1
            
        if T:
            log.info("PASSED:isolated host is present before reload")
        else:
            log.error("FAILED:isolated host is not present before reload")
            self.failed()    
        
        log.info(banner("MEM-STATS"))
        out1 = []
        process = ["l2fm" , "ethpm" , "private-vlan"]
        for p in process:
            a = buglib.mem_leak(uut1,p)
            out1.append(a) 
        
        buglib.reload(uut1)  
        
        out2 = []
        for p in process:
            a = buglib.mem_leak(uut1,p)
            out2.append(a)
        
        if out1 == out2:
            log.info("Passed:mem-stats are in before reload and after reload")
            tab3 = '\t\t\t\t'
            tab2 = '\t\t\t'
            tab1 = '\t\t'
            log.info(f"Before reload{tab3}After reload")         
            log.info(f"l2fm:- {out1[0]}{tab2}l2fm:- {out2[0]}")
            log.info(f"ethpm:- {out1[1]}{tab2}ethpm:- {out2[1]}")
            log.info(f"private-vlan:- {out1[2]}{tab1}private-vlan:- {out2[2]}")
        elif out1 != out2:
            o = 0
            pount = 0
            v = 0
            log.info("mem-stats are not same in before reload and after reload")
            while o < len(process):
                if out1[o] == out2[o]:
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                elif out1[o] < out2[o]:    
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                    pount += 1
                    v = o
                elif out1[o] > out2[o]:
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                o += 1
            if pount != 0:
                self.failed(f" In {process[v]}:- before reload {out1[v]}\n after reload {out2[v]}")
        
        oUt=uut1.execute("""show vlan private-vlan""")
        a = 0
        count = 10
        while interfaces[a] != interfaces[40]:
            v = count
            iso = count+1
            c1 = count+2
            pattern = fr'^\s*{v}\s*{iso}\s*[Ii]solated\s*{interfaces[a]}\s*$'
            if re.findall(pattern, oUt, re.MULTILINE):
                T = True
            else:
               
                T = False
            count+=3
            a+=1
            
        if T:
            log.info("PASSED:isolated host is present after reload")
        else:
            log.error("FAILED:isolated host is not present after reload")
            self.failed()
            
        uut1.execute("show mac address-table dynamic")
        
        uut1.execute("show interface counters brief 1")    
        
        uut1.execute("python cliRunTime.py input_cli_file.txt",timeout = 3000)
        
    @aetest.cleanup
    def clean_n_default(self,testbed,testscript):     
        uut1.configure("default interface ethernet regex [1]/",timeout = 600)
#################################################################################                   
class Test_5_(aetest.Testcase):
    @aetest.setup
    def creating_isolated_vlan_as_Isolated_trunk_in_single_interface(self,testbed,testscript):
        global et
        et = interfaces[0]
        log.info(banner(f"Making Isolated trunk Vlan as host on {et} interface of {uut1.name}"))
        count = 10
        l = 55
        end = int(l)
        uut1.configure(f"""interface {et}\n switchport\n switchport mode private-vlan trunk secondary\n no shut""")
        while(count <= end):
            vla = count 
            iso = count+1 
            com1 = count+2
            buglib.iso_trunk_host(et,vla,iso,uut1)
            count+=3
            
        out=uut1.execute("""show vlan private-vlan""")
     
        count = 10
        l = 55
        end = int(l)
        while(count <= end):
            vla = count 
            iso = count+1 
            com1 = count+2
            pattern = fr'^\s*{vla}\s*{iso}\s*[Ii]solated\s*{et}\s*$'
            if re.findall(pattern, out, re.MULTILINE):
                T = True
            else:
                
                T = False
            count+=3

        if T:
            log.info("PASSED:isolated trunk host is present before reload")
        else:
            log.error("FAILED:isolated trunk host is not present before reload")
            self.failed()     
        
        log.info(banner("MEM-STATS"))
        out1 = []
        process = ["l2fm" , "ethpm" , "private-vlan"]
        for p in process:
            a = buglib.mem_leak(uut1,p)
            out1.append(a) 
        
        buglib.ascii_reload(uut1)  
        
        out2 = []
        for p in process:
            a = buglib.mem_leak(uut1,p)
            out2.append(a)
        
        if out1 == out2:
            log.info("Passed:mem-stats are in before reload and after reload")
            tab3 = '\t\t\t\t'
            tab2 = '\t\t\t'
            tab1 = '\t\t'
            log.info(f"Before reload{tab3}After reload")         
            log.info(f"l2fm:- {out1[0]}{tab2}l2fm:- {out2[0]}")
            log.info(f"ethpm:- {out1[1]}{tab2}ethpm:- {out2[1]}")
            log.info(f"private-vlan:- {out1[2]}{tab1}private-vlan:- {out2[2]}")
        elif out1 != out2:
            o = 0
            pount = 0
            v = 0
            log.info("mem-stats are not same in before reload and after reload")
            while o < len(process):
                if out1[o] == out2[o]:
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                elif out1[o] < out2[o]:    
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                    pount += 1
                    v = o
                elif out1[o] > out2[o]:
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                o += 1
            if pount != 0:
                self.failed(f" In {process[v]}:- before reload {out1[v]}\n after reload {out2[v]}")
        
        out=uut1.execute("""show vlan private-vlan""")
     
        count = 10
        l = 55
        end = int(l)
        while(count <= end):
            vla = count 
            iso = count+1 
            com1 = count+2
            pattern = fr'^\s*{vla}\s*{iso}\s*[Ii]solated\s*{et}\s*$'
            if re.findall(pattern, out, re.MULTILINE):
                T = True
            else:
                
                T = False
            count+=3

        if T:
            log.info("PASSED:isolated trunk host is present after reload")
        else:
            log.error("FAILED:isolated trunk host is not present after reload")
            self.failed()
            
        uut1.execute("show mac address-table dynamic")
        
        uut1.execute("show interface counters brief 1")    
            
        uut1.execute("python cliRunTime.py input_cli_file.txt",timeout = 3000)    
            
    @aetest.cleanup
    def clean_n_default(self,testbed,testscript):    
        uut1.configure(f"default interface {et}",timeout = 600)
#################################################################################        
class Test_6_(aetest.Testcase):
    @aetest.test
    def creating_Promiscous_trunk_port_for_5_interface(self,testbed,testscript):
        log.info(banner("CREATING PROMISCOUS TRUNK PORT FOR 5 INTERFACE"))
        a = 0 
        count = 10
        while interfaces[a] <= interfaces[4]:
            vla = count
            iso = count + 1
            com1 = count + 2
            buglib.prom_trunk_host(interfaces[a], vla, iso, com1, uut1)
            a += 1
            count += 3
            
        out = uut1.execute("show vlan private-vlan")
        
        a = 0
        count = 10
        while interfaces[a] <= interfaces[4]:
            vla = count 
            iso = count+1 
            com1 = count+2
            pattern1 = fr'^\s*{vla}\s*{iso}\s*[Ii]solated\s*{interfaces[a]}\s*$'
            pattern2 = fr'^\s*{vla}\s*{com1}\s*[Cc]ommunity\s*{interfaces[a]}\s*$'
            if re.findall(pattern1, out, re.MULTILINE) and re.findall(pattern2, out, re.MULTILINE):
                T = True
            else:
                T = False
            count+=3
            a+=1
            
        if T:
            log.info("PASSED:promiscous trunk host is present before reload")
        else:
            log.error("FAILED:promiscous trunk host is not present before reload")
            self.failed()    
        
        log.info(banner("MEM-STATS"))
        out1 = []
        process = ["l2fm" , "ethpm" , "private-vlan"]
        for p in process:
            a = buglib.mem_leak(uut1,p)
            out1.append(a) 
        
        buglib.reload(uut1)  
        
        out2 = []
        for p in process:
            a = buglib.mem_leak(uut1,p)
            out2.append(a)
        
        if out1 == out2:
            log.info("Passed:mem-stats are in before reload and after reload")
            tab3 = '\t\t\t\t'
            tab2 = '\t\t\t'
            tab1 = '\t\t'
            log.info(f"Before reload{tab3}After reload")         
            log.info(f"l2fm:- {out1[0]}{tab2}l2fm:- {out2[0]}")
            log.info(f"ethpm:- {out1[1]}{tab2}ethpm:- {out2[1]}")
            log.info(f"private-vlan:- {out1[2]}{tab1}private-vlan:- {out2[2]}")
        elif out1 != out2:
            o = 0
            pount = 0
            v = 0
            log.info("mem-stats are not same in before reload and after reload")
            while o < len(process):
                if out1[o] == out2[o]:
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                elif out1[o] < out2[o]:    
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                    pount += 1
                    v = o
                elif out1[o] > out2[o]:
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                o += 1
            if pount != 0:
                self.failed(f" In {process[v]}:- before reload {out1[v]}\n after reload {out2[v]}")
                
        out = uut1.execute("show vlan private-vlan")
        
        a = 0
        count = 10
        while interfaces[a] <= interfaces[4]:
            vla = count 
            iso = count+1 
            com1 = count+2
            pattern1 = fr'^\s*{vla}\s*{iso}\s*[Ii]solated\s*{interfaces[a]}\s*$'
            pattern2 = fr'^\s*{vla}\s*{com1}\s*[Cc]ommunity\s*{interfaces[a]}\s*$'
            if re.findall(pattern1, out, re.MULTILINE) and re.findall(pattern2, out, re.MULTILINE):
                T = True
            else:
                T = False
            count+=3
            a+=1
            
        if T:
            log.info("PASSED:promiscous trunk host is present after reload")
        else:
            log.error("FAILED:promiscous trunk host is not present after reload")
            self.failed()
            
        uut1.execute("show mac address-table dynamic")
        
        uut1.execute("show interface counters brief 1")    
            
        uut1.execute("python cliRunTime.py input_cli_file.txt",timeout = 3000)    
            
    @aetest.cleanup
    def clean_n_default(self,testbed,testscript):    
        uut1.configure(f"default interface ethernet regex [1]/",timeout = 600)
#################################################################################        
class Test_7_(aetest.Testcase):
    @aetest.test
    def creating_Promiscous_port_for_5_interface(self,testbed,testscript):
        log.info(banner("CREATING PROMISCOUS TRUNK HOST FOR 5 INTERFACE"))
        a = 0
        count = 10
        while interfaces[a] <= interfaces[4]:
            vla = count
            iso = count + 1
            com1 = count + 2
            buglib.prom_host(interfaces[a], vla, iso, com1, uut1)
            a += 1
            count += 3
        
        log.info(banner("MEM-STATS"))
        out1 = []
        process = ["l2fm" , "ethpm" , "private-vlan"]
        for p in process:
            a = buglib.mem_leak(uut1,p)
            out1.append(a) 
        
        buglib.reload(uut1)  
        
        out2 = []
        for p in process:
            a = buglib.mem_leak(uut1,p)
            out2.append(a)
        
        if out1 == out2:
            log.info("Passed:mem-stats are in before reload and after reload")
            tab3 = '\t\t\t\t'
            tab2 = '\t\t\t'
            tab1 = '\t\t'
            log.info(f"Before reload{tab3}After reload")         
            log.info(f"l2fm:- {out1[0]}{tab2}l2fm:- {out2[0]}")
            log.info(f"ethpm:- {out1[1]}{tab2}ethpm:- {out2[1]}")
            log.info(f"private-vlan:- {out1[2]}{tab1}private-vlan:- {out2[2]}")
        elif out1 != out2:
            o = 0
            pount = 0
            v = 0
            log.info("mem-stats are not same in before reload and after reload")
            while o < len(process):
                if out1[o] == out2[o]:
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                elif out1[o] < out2[o]:    
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                    pount += 1
                    v = o
                elif out1[o] > out2[o]:
                    log.info(f"before reload {process[o]}:- {out1[o]}\nafter reload {process[o]}:- {out2[o]}")
                o += 1
            if pount != 0:
                self.failed(f" In {process[v]}:- before reload {out1[v]}\n after reload {out2[v]}")
        
        uut1.execute("show vlan private-vlan")
        
        uut1.execute("show mac address-table dynamic")
        
        uut1.execute("show interface counters brief 1")
        
        uut1.execute("python cliRunTime.py input_cli_file.txt",timeout = 3000)
        
    @aetest.cleanup
    def clean_n_default(self,testbed,testscript):    
        uut1.configure("default interface ethernet regex [1]/",timeout = 600)
        
        ###########################################################################################################
        
#     ### If Interfaces are given from yaml file ###
#     ##############################################
#
# class community_host(aetest.Testcase):
#     @aetest.setup
#     def creating_community_vlan_as_host_in_every_interface(self,testbed,testscript):
#         log.info(banner(f"Making Community Vlan as host on every interface of {uut1.name}"))
#         # out = uut1.execute("""sh int br | grep "Eth1/" | count""")
#         # end = int(out)
#         count = 10
#         e = 1
#         l = 40
#         end = int(l)
#         while(e <= end):
#             vla = count 
#             iso = count+1 
#             com1 = count+2
#             buglib.com1_host(e,vla,com1,uut1)
#             e+=1
#             count+=3
#         time.sleep(10)
#         buglib.reload(uut1) 
#         uut1.execute("""show vlan private-vlan | grep "community        Eth" | count""")
#         uut1.configure(f"default int eth 1/1-{end}",timeout=600)
#                         
# class Isolated_host(aetest.Testcase):
#     @aetest.setup
#     def creating_isolated_vlan_as_host_in_every_interface(self,testbed,testscript):
#         log.info(banner(f"Making Isolated Vlan as host on every interface of {uut1.name}"))
#         # out = uut1.execute("""sh int br | grep "Eth1/" | count""")
#         # end = int(out)
#         count = 10
#         e = 1
#         l = 40
#         end = int(l)
#         while(e <= end):
#             vla = count 
#             iso = count+1 
#             com1 = count+2
#             buglib.iso_host(e,vla,iso,uut1)
#             e+=1
#             count+=3
#         time.sleep(10)
#         buglib.reload(uut1)     
#         uut1.configure("""show vlan private-vlan""")
#         uut1.execute("""show vlan private-vlan | grep "isolated         Eth" | count""")
#         uut1.configure(f"default int eth 1/1-{end}",timeout=600)
#         
# class Isolated_trunk_host(aetest.Testcase):
#     @aetest.setup
#     def creating_isolated_vlan_as_Isolated_trunk_in_single_interface(self,testbed,testscript):
#         eth = testbed.custom['interface']
#         log.info(banner(f"Making Isolated Vlan as host on every interface of {uut1.name}"))
#         count = 10
#         l = 55
#         end = int(l)
#         uut1.configure(f"""interface {eth}\n switchport\n switchport mode private-vlan trunk secondary\n no shut""")
#         while(count <= end):
#             vla = count 
#             iso = count+1 
#             com1 = count+2
#             buglib.iso_trunk_host(eth,vla,iso,uut1)
#             count+=3
#         time.sleep(10)
#         buglib.reload(uut1)     
#         uut1.configure("""show vlan private-vlan""")
#         uut1.execute("""show vlan private-vlan | grep "isolated         Eth" | count""")
#         uut1.configure(f"default int {eth}",timeout=600)
#         
# class promiscous_trunk_host(aetest.Testcase):
#     @aetest.test
#     def creating_Promiscous_trunk_port_for_every_interface(self,testbed,testscript):
#         log.info(banner("CREATING PROMISCOUS TRUNK HOST"))
#         count = 10
#         e = 1
#         l = 5
#         end = int(l)
#         while(e <= end):
#             vla = count 
#             iso = count+1 
#             com1 = count+2
#             buglib.prom_trunk_host(e,vla,iso,com1,uut1)
#             e+=1
#             count+=3
#         time.sleep(10)
#         buglib.reload(uut1) 
#         uut1.execute("show vlan private-vlan | count")
#         uut1.configure(f""" default int eth 1/1-{end}""",timeout=600)
#         
# class promiscous_host(aetest.Testcase):
#     @aetest.test
#     def creating_Promiscous_port_for_every_interface(self,testbed,testscript):
#         log.info(banner("CREATING PROMISCOUS TRUNK HOST"))
#         count = 10
#         e = 1
#         l = 5
#         end = int(l)
#         while(e <= end):
#             vla = count 
#             iso = count+1 
#             com1 = count+2
#             buglib.prom_host(e,vla,iso,com1,uut1)
#             e+=1
#             count+=3
#         time.sleep(10)
#         buglib.reload(uut1) 
#         uut1.execute("show vlan private-vlan | count")
#         uut1.configure(f""" default int eth 1/1-{end}""",timeout=600)
#        
################################################################################
####                       COMMON CLEANUP SECTION                           ####
################################################################################
        
class common_cleanup(aetest.CommonCleanup):
    @aetest.subsection
    def removing_all_configurations(self,testbed,testscript):
        log.info(banner("REMOVING THE CONFIGURED VLANs"))
        uut1.configure("default interface ethernet regex [1]/",timeout = 600)
        uut1.configure(""" no feature private-vlan\n feature private-vlan""",timeout = 600)
        uut1.configure(f"copy {file} running-config",timeout = 600)
        uut1.transmit(f"delete {file}\r")
        uut1.receive("Do you want to delete ")
        uut1.transmit("y\r")
        uut1.receive("#")
        uut1.disconnect()
        log.info(banner("Successfully disconnecting from the device.")) 
